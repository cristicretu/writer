"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("amp",{

/***/ "./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/router.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/router.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _classCallCheck = (__webpack_require__(/*! @swc/helpers/lib/_class_call_check.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_class_call_check.js\")[\"default\"]);\nvar _createClass = (__webpack_require__(/*! @swc/helpers/lib/_create_class.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_create_class.js\")[\"default\"]);\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\nvar _tsGenerator = (__webpack_require__(/*! @swc/helpers/lib/_ts_generator.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_ts_generator.js\")[\"default\"]);\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchesMiddleware = matchesMiddleware;\nexports.createKey = createKey;\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _removeTrailingSlash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/script.js\");\nvar _isError = _interop_require_wildcard(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../mitt */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolveRewrites = _interop_require_default(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?22fb\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formatUrl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectDomainLocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsePath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addLocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/add-locale.js\");\nvar _removeLocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/remove-locale.js\");\nvar _removeBasePath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/remove-base-path.js\");\nvar _addBasePath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/add-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/client/has-base-path.js\");\nvar _isApiRoute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/lib/is-api-route.js\");\nvar _getNextPathnameInfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatNextPathnameInfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _compareStates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _isLocalUrl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isBot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _resolveHref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nvar _interpolateAs = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handleSmoothScroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function(options) {\n        var matchers, _parsePath1, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _parsePath1 = (0, _parsePath).parsePath(options.asPath), asPathname = _parsePath1.pathname;\n                    cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _resolveHref1 = _slicedToArray((0, _resolveHref).resolveHref(router, url, true), 2), resolvedHref = _resolveHref1[0], resolvedAs = _resolveHref1[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolveHref).resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            var pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest()\n            ]).then(function(param) {\n                var _param = _slicedToArray(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    var matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsePath).parsePath(source);\n        var pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsePath).parsePath(redirectTarget);\n            var pathname1 = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\".concat(pathname1).concat(src1.query).concat(src1.hash),\n                newUrl: \"\".concat(pathname1).concat(src1.query).concat(src1.hash)\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator(function(options) {\n        var matches, data, effect, e;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var ref1;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch(function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeLoader).markAssetError(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"'.concat(route, '\"'));\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname1, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === (0, _addBasePath).addBasePath(_this.asPath) && pathname1 === (0, _addBasePath).addBasePath(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/bloom-filter/index.js\").BloomFilter);\n            var staticFilterData = {\"bitset\":{\"size\":24,\"content\":\"psoD\"},\"hashes\":7,\"size\":20};\n            var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n            if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as1 !== pathname1;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Go forward in history\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, ref, ref2, _i1, _iter1, normalizedAS, curAsParts, i, ref3, currentPart;\n                    return _tsGenerator(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removeTrailingSlash).removeTrailingSlash(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removeTrailingSlash).removeTrailingSlash(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((ref = _this._bfl_s) == null ? void 0 : ref.has(asNoSlash)) || !!((ref2 = _this._bfl_s) == null ? void 0 : ref2.has(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((ref3 = _this._bfl_d) == null ? void 0 : ref3.has(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            handleHardNavigation({\n                                                url: (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, locale || _this.locale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref1, ref2, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, ref4, ref5, ref6, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _route, isValidShallowRoute, _scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, ref7, ref8, ref9, err2, canSkipUpdating, e, hashRegex, err11;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _isLocalUrl).isLocalURL(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                isQueryUpdating = options._h === 1;\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n                                nextState = _extends({}, _this.state);\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _extends({}, options, {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _isError).default(err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeLoader).getClientBuildManifest(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref1 = _slicedToArray.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref1[0], ref2 = ref1[1], rewrites = ref2.__rewrites, ref2, ref1;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formatUrl).formatWithValidation(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _isLocalUrl).isLocalURL(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"'.concat(url, '\" and as: \"').concat(as, '\", received relative href and external as') + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                routeMatch = false;\n                                if ((0, _isDynamic).isDynamicRoute(route)) {\n                                    parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                    routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateAs).interpolateAs(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(\", \"), \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(\", \"), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\"));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit).omit(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeRegex).getRouteRegex(pathname);\n                                        curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script).handleClientScriptLoad(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isNotFound: true\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((ref4 = self.__NEXT_DATA__.props) == null ? void 0 : (ref5 = ref4.pageProps) == null ? void 0 : ref5.statusCode) === 500 && ((ref6 = routeInfo.props) == null ? void 0 : ref6.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                                shouldScroll = (_scroll = options.scroll) != null ? _scroll : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                upcomingRouterState = _extends({}, nextState, {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \".concat(_this.pathname));\n                                }\n                                if (_this.pathname === \"/_error\" && ((ref7 = self.__NEXT_DATA__.props) == null ? void 0 : (ref8 = ref7.pageProps) == null ? void 0 : ref8.statusCode) === 500 && ((ref9 = routeInfo.props) == null ? void 0 : ref9.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _isError).default(err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err11 = _state.sent();\n                                if ((0, _isError).default(err11) && err11.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err11;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                var _this = this;\n                return _async_to_generator(function() {\n                    var route, ref, ref10, ref11, ref12, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formatUrl).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    }).catch(function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                // when rendering error routes we don't apply middleware\n                                // effects\n                                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                                    data.effect = undefined;\n                                }\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === \"redirect-internal\" || (data == null ? void 0 : (ref10 = data.effect) == null ? void 0 : ref10.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (ref11 = data.effect) == null ? void 0 : ref11.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _extends({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _extends({}, existingInfo, {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isApiRoute).isAPIRoute(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"'.concat(pathname, '\"'));\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (ref12 = data.response) == null ? void 0 : ref12.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(_async_to_generator(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _tsGenerator(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formatUrl).formatWithValidation({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _slicedToArray(this.asPath.split(\"#\"), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _slicedToArray(as.split(\"#\"), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _slicedToArray(as.split(\"#\"), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === \"\" || hash === \"top\") {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return window.scrollTo(0, 0);\n                    });\n                    return;\n                }\n                // Decode hash to make non-latin anchor works.\n                var rawHash = decodeURIComponent(hash);\n                // First we check if the element by id is found\n                var idEl = document.getElementById(rawHash);\n                if (idEl) {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return idEl.scrollIntoView();\n                    });\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(rawHash)[0];\n                if (nameEl) {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return nameEl.scrollIntoView();\n                    });\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ key: \"prefetch\",\n            value: function prefetch(url) {\n                var asPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : url, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var _this = this;\n                return _async_to_generator(function() {\n                    var parsed, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isBot).isBot(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeLoader).getClientBuildManifest()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolveRewrites).default((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formatUrl).formatWithValidation({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _extends({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 8:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var handleCancelled, componentResult, err;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy4yLjRfYmlxYmFib3BsZmJyZXR0ZDc2NTVmcjRuMnkvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHlCQUF5QixHQUFHRTtBQUM1QkYsaUJBQWlCLEdBQUdHO0FBQ3BCSCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUssc0JBQXNCQyxnTEFBMEQ7QUFDcEYsSUFBSUMsV0FBV0QsMEpBQStDO0FBQzlELElBQUlFLDJCQUEyQkYsMExBQStEO0FBQzlGLElBQUlHLDRCQUE0QkgsNExBQWdFO0FBQ2hHLElBQUlJLHVCQUF1QkosbUJBQU9BLENBQUMsMEtBQStCO0FBQ2xFLElBQUlLLGVBQWVMLG1CQUFPQSxDQUFDLCtJQUE4QjtBQUN6RCxJQUFJTSxVQUFVTixtQkFBT0EsQ0FBQyxtSUFBd0I7QUFDOUMsSUFBSU8sV0FBV0osMEJBQTBCSCxtQkFBT0EsQ0FBQyxpSUFBdUI7QUFDeEUsSUFBSVEsdUJBQXVCUixtQkFBT0EsQ0FBQyw0S0FBb0M7QUFDdkUsSUFBSVMsdUJBQXVCVCxtQkFBT0EsQ0FBQyxrS0FBK0I7QUFDbEUsSUFBSVUsUUFBUVIseUJBQXlCRixtQkFBT0EsQ0FBQyxzSEFBUztBQUN0RCxJQUFJVyxTQUFTWCxtQkFBT0EsQ0FBQyx3SEFBVTtBQUMvQixJQUFJWSxhQUFhWixtQkFBT0EsQ0FBQyxvSkFBb0I7QUFDN0MsSUFBSWEsb0JBQW9CYixtQkFBT0EsQ0FBQyxvS0FBNEI7QUFDNUQsSUFBSWMsbUJBQW1CWix5QkFBeUJGLG1CQUFPQSxDQUFDLHVDQUEwQjtBQUNsRixJQUFJZSxnQkFBZ0JmLG1CQUFPQSxDQUFDLDBKQUF1QjtBQUNuRCxJQUFJZ0IsY0FBY2hCLG1CQUFPQSxDQUFDLHNKQUFxQjtBQUMvQyxJQUFJ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WTtnQkFDUixPQUFPLElBQUksQ0FBQ3FCLEtBQUssQ0FBQ3JCLEtBQUs7WUFDM0I7OztZQUNJckosS0FBQUE7aUJBQUosZUFBZTtnQkFDWCxPQUFPLElBQUksQ0FBQzBLLEtBQUssQ0FBQzFLLFFBQVE7WUFDOUI7OztZQUNJdUUsS0FBQUE7aUJBQUosZUFBWTtnQkFDUixPQUFPLElBQUksQ0FBQ21HLEtBQUssQ0FBQ25HLEtBQUs7WUFDM0I7OztZQUNJeEUsS0FBQUE7aUJBQUosZUFBYTtnQkFDVCxPQUFPLElBQUksQ0FBQzJLLEtBQUssQ0FBQzNLLE1BQU07WUFDNUI7OztZQUNJTSxLQUFBQTtpQkFBSixlQUFhO2dCQUNULE9BQU8sSUFBSSxDQUFDcUssS0FBSyxDQUFDckssTUFBTTtZQUM1Qjs7O1lBQ0k2SixLQUFBQTtpQkFBSixlQUFpQjtnQkFDYixPQUFPLElBQUksQ0FBQ1EsS0FBSyxDQUFDUixVQUFVO1lBQ2hDOzs7WUFDSUUsS0FBQUE7aUJBQUosZUFBZ0I7Z0JBQ1osT0FBTyxJQUFJLENBQUNNLEtBQUssQ0FBQ04sU0FBUztZQUMvQjs7O1dBNWtDRVg7O0FBcXdDTkEsT0FBT3lELE1BQU0sR0FBRyxDQUFDLEdBQUc5UCxLQUFLLEVBQUVaLE9BQU87QUFDbENKLGtCQUFlLEdBQUdxTixRQUVsQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMi40X2JpcWJhYm9wbGZicmV0dGQ3NjU1ZnI0bjJ5L25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzP2Q5MzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoZXNNaWRkbGV3YXJlID0gbWF0Y2hlc01pZGRsZXdhcmU7XG5leHBvcnRzLmNyZWF0ZUtleSA9IGNyZWF0ZUtleTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xudmFyIF9yZXNvbHZlUmV3cml0ZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbnZhciBfZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcGF0aFwiKTtcbnZhciBfYWRkTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xudmFyIF9yZW1vdmVMb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG52YXIgX3JlbW92ZUJhc2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG52YXIgX2lzQXBpUm91dGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWFwaS1yb3V0ZVwiKTtcbnZhciBfZ2V0TmV4dFBhdGhuYW1lSW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG52YXIgX2Zvcm1hdE5leHRQYXRobmFtZUluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xudmFyIF9jb21wYXJlU3RhdGVzID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcGFyZS1zdGF0ZXNcIik7XG52YXIgX2lzTG9jYWxVcmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG52YXIgX2lzQm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xudmFyIF9vbWl0ID0gcmVxdWlyZShcIi4vdXRpbHMvb21pdFwiKTtcbnZhciBfcmVzb2x2ZUhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XG52YXIgX2ludGVycG9sYXRlQXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbnZhciBfaGFuZGxlU21vb3RoU2Nyb2xsID0gcmVxdWlyZShcIi4vdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tYXRjaGVzTWlkZGxld2FyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX21hdGNoZXNNaWRkbGV3YXJlKCkge1xuICAgIF9tYXRjaGVzTWlkZGxld2FyZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcnMgPSB5aWVsZCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgICAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAgICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xuICAgICAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgICAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgICAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZUhyZWYpLnJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlSHJlZikucmVzb2x2ZUhyZWYocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKCgwLCBfZGVub3JtYWxpemVQYWdlUGF0aCkuZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmV3cml0ZScpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtbWF0Y2hlZC1wYXRoJyk7XG4gICAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1tYXRjaGVkLXBhdGgnKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCdfX25leHRfZGF0YV9jYXRjaGFsbCcpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnL19lcnJvcicpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnLzQwNCcpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8ocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksIFxuICAgICAgICAgICAgXSkudGhlbigoW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSk9PntcbiAgICAgICAgICAgICAgICBsZXQgYXMgPSAoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0TmV4dFBhdGhuYW1lSW5mbykuZ2V0TmV4dFBhdGhuYW1lSW5mbygoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoc291cmNlKS5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogJydcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZWRpcmVjdCcpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiAnJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWludGVybmFsJyxcbiAgICAgICAgICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICAgICAgICAgIG5ld1VybDogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF93aXRoTWlkZGxld2FyZUVmZmVjdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF93aXRoTWlkZGxld2FyZUVmZmVjdHMoKSB7XG4gICAgX3dpdGhNaWRkbGV3YXJlRWZmZWN0cyA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHlpZWxkIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1hdGNoZXMgfHwgIW9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3QgPSB5aWVsZCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICBlZmZlY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAqIFRPRE86IFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cbiAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAqLyByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfd2l0aE1pZGRsZXdhcmVFZmZlY3RzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICd4LW5leHRqcy1kYXRhJzogJzEnXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YSh7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0pIHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciByZWYxO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiAncHJlZmV0Y2gnXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZldGNoJzogJzEnXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAocmVmMSA9IHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgIT0gbnVsbCA/IHJlZjEgOiAnR0VUJ1xuICAgICAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiByZWYubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhc1xuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICovIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLm1hcmtBc3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLyBjaHJvbWVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJyB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJyB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTG9hZCBmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikubWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAgIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAgIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShpc0JhY2tncm91bmQgPyB7XG4gICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgfSA6IHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xufVxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmwgLCByb3V0ZXIgIH0pIHtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCAke3VybH0gJHtsb2NhdGlvbi5ocmVmfWApO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAoeyByb3V0ZSAsIHJvdXRlciAgfSk9PntcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChuZXcgVVJMKGN1ckFzLCAnaHR0cDovL24nKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGFzTm9TbGFzaCwgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKG5ldyBVUkwoX3RoaXMuYXNQYXRoLCAnaHR0cDovL24nKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmLCByZWYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChyZWYgPSBfdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiByZWYuaGFzKGFzTm9TbGFzaCkpIHx8ICEhKChyZWYyID0gX3RoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMi5oYXMoYXNOb1NsYXNoTG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChyZWYzID0gX3RoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMy5oYXMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhcywgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgaWYgKCEoMCwgX2lzTG9jYWxVcmwpLmlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID0gaXNRdWVyeVVwZGF0aW5nIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgodXJsKS5wYXRobmFtZSA9PT0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChhcykucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgX3RoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSBfdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBpc1NzciA9IF90aGlzLmlzU3NyO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1NzciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IF90aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXMpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgodXJsKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHVybCkgOiB1cmwsIF90aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoISgocmVmID0gX3RoaXMubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSAoMCwgX2RldGVjdERvbWFpbkxvY2FsZSkuZGV0ZWN0RG9tYWluTG9jYWxlKF90aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiBfdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtkZXRlY3RlZERvbWFpbi5kb21haW59JHsoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChgJHtuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bmV4dFN0YXRlLmxvY2FsZX1gfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJyl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgICAgICBpZiAoX3V0aWxzLlNUKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9ZmFsc2UgLCBzY3JvbGwgPXRydWUgIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBzaGFsbG93XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKF90aGlzLl9pbkZsaWdodFJvdXRlICYmIF90aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBfdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmNsYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcyA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXMpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMsIG9wdGlvbnMubG9jYWxlLCBfdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZUxvY2FsZSkucmVtb3ZlTG9jYWxlKCgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIF90aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVybCBjaGFuZ2UgaXMgb25seSByZWxhdGVkIHRvIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIF90aGlzLm9ubHlBSGFzaENoYW5nZShjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLnNldChuZXh0U3RhdGUsIF90aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgICAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAgICAgICAgIC8vIHdoZW4gcmV3cml0dGVuIHRvXG4gICAgICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH1dID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCksIFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgICAgICBpZiAoIV90aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAgICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgICAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZSA/ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXRobmFtZSkpIDogcGF0aG5hbWU7XG4gICAgICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoJy8nKSAmJiAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpIHx8ICEoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmICh5aWVsZCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdCgoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzTG9jYWxVcmwpLmlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVMb2NhbGUpLnJlbW92ZUxvY2FsZSgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyb3V0ZSk7XG4gICAgICAgICAgICAgICAgcm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZUFzKS5pbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7c2hvdWxkSW50ZXJwb2xhdGUgPyBgSW50ZXJwb2xhdGluZyBocmVmYCA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgKyBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0KS5vbWl0KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IF90aGlzLnBhdGhuYW1lID09PSAnLzQwNCcgfHwgX3RoaXMucGF0aG5hbWUgPT09ICcvX2Vycm9yJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZjQsIHJlZjUsIHJlZjY7XG4gICAgICAgICAgICAgICAgbGV0IHJvdXRlSW5mbyA9IHlpZWxkIF90aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICFfdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5fYmZsKGFzLCAncmVzb2x2ZWRBcycgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3JvdXRlJyBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRQYXRobmFtZSA9ICgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSkgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXJzZWQucGF0aG5hbWUpIDogcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID0gIXJvdXRlUHJvcHMuc2hhbGxvdyAmJiByb3V0ZUluZm8ucmVzb2x2ZWRBcyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocmV3cml0ZUFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHJld3JpdGVBcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChyZXdyaXRlQXMsIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGN1clJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxuICAgICAgICAgICAgICAgIGlmICgndHlwZScgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8udHlwZSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQpLmhhbmRsZUNsaWVudFNjcmlwdExvYWQoc2NyaXB0LnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RfQkFTRV9QQVRIICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZEhyZWYucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsICwgYXM6IG5ld0FzICB9ID0gcHJlcGFyZVVybEFzKF90aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmlzUHJldmlldyA9ICEhcm91dGVJbmZvLnByb3BzLl9fTl9QUkVWSUVXO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdEZvdW5kUm91dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvNDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy9fZXJyb3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0geWllbGQgX3RoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmNCA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY1ID0gcmVmNC5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByZWY1LnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChyZWY2ID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmNi5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yb3V0ZTtcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxuICAgICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgICAgIC8vIHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnQuIFRoaXMgaXMgYWxzbyB3aHkgdGhpcyBibG9jayBpcyBiZWZvcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNFcnJvclJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY3LCByZWY4LCByZWY5O1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAke190aGlzLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmNyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY4ID0gcmVmNy5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByZWY4LnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChyZWY5ID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmOS5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIGZvciBxdWVyeSB1cGRhdGVzIHdlIGNhbiBza2lwIGl0IGlmIHRoZSBzdGF0ZSBpcyB1bmNoYW5nZWQgYW5kIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuU2tpcFVwZGF0aW5nID0gaXNRdWVyeVVwZGF0aW5nICYmICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmICFyZWFkeVN0YXRlQ2hhbmdlICYmICFsb2NhbGVDaGFuZ2UgJiYgKDAsIF9jb21wYXJlU3RhdGVzKS5jb21wYXJlUm91dGVyU3RhdGVzKHVwY29taW5nUm91dGVyU3RhdGUsIF90aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hSZWdleCA9IC8jLiskLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvSGFzaChhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIxKSAmJiBlcnIxLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8ICgwLCBfdXRpbHMpLmdldFVSTCgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuX2tleSA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9yb3V0ZUxvYWRlcikuaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0geWllbGQgX3RoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0Um91dGVJbmZvKHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAsIGlzTm90Rm91bmQgIH0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICogVGhpcyBgcm91dGVgIGJpbmRpbmcgY2FuIGNoYW5nZSBpZiB0aGVyZSdzIGEgcmV3cml0ZVxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxuICAgICAqIHNvIHdlIGNhbiBzdG9yZSB0aGUgY2FjaGUgZm9yIGl0IGFuZCBhdm9pZCByZS1yZXF1ZXN0aW5nIGV2ZXJ5IHRpbWVcbiAgICAgKiBmb3Igc2hhbGxvdyByb3V0aW5nIHB1cnBvc2VzLlxuICAgICAqLyBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiwgcmVmMTAsIHJlZjExLCByZWYxMjtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gX3RoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgX3RoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKCdpbml0aWFsJyBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnID8gZXhpc3RpbmdJbmZvIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IGlzQmFja2dyb3VuZCA/IF90aGlzLnNiYyA6IF90aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/ICcvNDA0JyA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgKHBhdGhuYW1lID09PSAnL19lcnJvcicgfHwgcGF0aG5hbWUgPT09ICcvNDA0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5lZmZlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50eXBlKSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJyB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKHJlZjEwID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiByZWYxMC50eXBlKSA9PT0gJ3JlZGlyZWN0LWV4dGVybmFsJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKHJlZjExID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiByZWYxMS50eXBlKSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2goZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZXMgPSB5aWVsZCBfdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtdHJhbnNpdGlvbiBhIHJlZGlyZWN0IHRoYXQgZG9lc24ndCBtYXRjaCBhIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgfHwgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRSb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBfZXh0ZW5kcyh7fSwgcXVlcnksIGRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0luZm8gPSBfdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIF90aGlzLnJvdXRlID09PSByb3V0ZSAmJiAhaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3ZSByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGFsb25nIHdpdGggdGhlIG1hdGNoZWQgcm91dGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBleGlzdGluZ0luZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0FwaVJvdXRlKS5pc0FQSVJvdXRlKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGNhY2hlZFJvdXRlSW5mbyB8fCAoeWllbGQgX3RoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUFxuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAocmVmMTIgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMTIuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1za2lwJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1A7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMgLCBjYWNoZUtleSAgfSA9IHlpZWxkIF90aGlzLl9nZXREYXRhKF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRmV0Y2hEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0geWllbGQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB3YXNCYWlsZWRQcmVmZXRjaCA/IHt9IDogX3RoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB5aWVsZCBfdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiBfdGhpcy5sb2NhbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IF90aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHgtbWlkZGxld2FyZS1jYWNoZTogbm8tY2FjaGUgYXMgd2VsbFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zZGNbY2FjaGVLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYSBub24tcHJlZmV0Y2ggcmVxdWVzdCBpcyBtYWRlIHRvIHNpZ25hbCByZXZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJiAhaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IF90aGlzLnNiY1xuICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8ucmVzb2x2ZWRBcyA9IHJlc29sdmVkQXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzRXJyb3IpLmdldFByb3BlckVycm9yKGVyciksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSAnJ10gPSBhcy5zcGxpdCgnIycpO1xuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlU21vb3RoU2Nyb2xsKS5oYW5kbGVTbW9vdGhTY3JvbGwoKCk9PndpbmRvdy5zY3JvbGxUbygwLCAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjb2RlIGhhc2ggdG8gbWFrZSBub24tbGF0aW4gYW5jaG9yIHdvcmtzLlxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmF3SGFzaCk7XG4gICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAoMCwgX2hhbmRsZVNtb290aFNjcm9sbCkuaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT5pZEVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlU21vb3RoU2Nyb2xsKS5oYW5kbGVTbW9vdGhTY3JvbGwoKCk9Pm5hbWVFbC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9pc0JvdCkuaXNCb3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgX3RoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBfdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0geWllbGQgX3RoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogX3RoaXMubG9jYWxlO1xuICAgICAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSB5aWVsZCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJld3JpdGVzO1xuICAgICAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9ID0geWllbGQgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZVJld3JpdGVzKS5kZWZhdWx0KCgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoYXNQYXRoLCBfdGhpcy5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZUxvY2FsZSkucmVtb3ZlTG9jYWxlKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIF90aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIoKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhcnNlZC5wYXRobmFtZSkpKCgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgoYXNQYXRoKS5wYXRobmFtZSkgfHwge30pO1xuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSAnc3RyaWN0JyA/IG51bGwgOiB5aWVsZCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBfdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IF90aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIV90aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfZXh0ZW5kcyh7fSwgcXVlcnksIGRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09ICdyZWRpcmVjdC1leHRlcm5hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSk7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgX3RoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSA/IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYgOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IF90aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIV90aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgX3RoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSwgXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IHlpZWxkIF90aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9nZXREYXRhKGZuKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHsgdGV4dCAgfSk9Pih7XG4gICAgICAgICAgICAgICAgZGF0YTogdGV4dFxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZTEsIHF1ZXJ5MSwgYXMxLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscykuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCAsIGFzICwgb3B0aW9ucyAsIGtleSAgfSA9IHN0YXRlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCh0aGlzLmFzUGF0aCkgJiYgcGF0aG5hbWUgPT09ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHRoaXMucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgICAgICAgICBfaDogMFxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZTEpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUxICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgIH0gPSByZXF1aXJlKCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5zaXplLCBzdGF0aWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5zaXplLCBkeW5hbWljRmlsdGVyRGF0YS5oYXNoZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kLmltcG9ydChkeW5hbWljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZTEpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhKDAsIF9kZXRlY3REb21haW5Mb2NhbGUpLmRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUxLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5MSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZTEgOiBhczEsXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMxLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMxICE9PSBwYXRobmFtZTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkxXG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiY3JlYXRlS2V5IiwiZGVmYXVsdCIsIl9hc3luY190b19nZW5lcmF0b3IiLCJyZXF1aXJlIiwiX2V4dGVuZHMiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX3JlbW92ZVRyYWlsaW5nU2xhc2giLCJfcm91dGVMb2FkZXIiLCJfc2NyaXB0IiwiX2lzRXJyb3IiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfcmVzb2x2ZVJld3JpdGVzIiwiX3JvdXRlTWF0Y2hlciIsIl9yb3V0ZVJlZ2V4IiwiX2Zvcm1hdFVybCIsIl9kZXRlY3REb21haW5Mb2NhbGUiLCJfcGFyc2VQYXRoIiwiX2FkZExvY2FsZSIsIl9yZW1vdmVMb2NhbGUiLCJfcmVtb3ZlQmFzZVBhdGgiLCJfYWRkQmFzZVBhdGgiLCJfaGFzQmFzZVBhdGgiLCJfaXNBcGlSb3V0ZSIsIl9nZXROZXh0UGF0aG5hbWVJbmZvIiwiX2Zvcm1hdE5leHRQYXRobmFtZUluZm8iLCJfY29tcGFyZVN0YXRlcyIsIl9pc0xvY2FsVXJsIiwiX2lzQm90IiwiX29taXQiLCJfcmVzb2x2ZUhyZWYiLCJfaW50ZXJwb2xhdGVBcyIsIl9oYW5kbGVTbW9vdGhTY3JvbGwiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiX21hdGNoZXNNaWRkbGV3YXJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtYXRjaGVycyIsImFzUGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJwYXRobmFtZSIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsImdldCIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwiX19yZXdyaXRlcyIsInJld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsIl93aXRoTWlkZGxld2FyZUVmZmVjdHMiLCJkYXRhIiwiZWZmZWN0IiwiZSIsImZldGNoRGF0YSIsImRhdGFIcmVmIiwianNvbiIsInRleHQiLCJjYWNoZUtleSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJmZXRjaE5leHREYXRhIiwiaW5mbGlnaHRDYWNoZSIsImlzUHJlZmV0Y2giLCJoYXNNaWRkbGV3YXJlIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXJzZUpTT04iLCJwZXJzaXN0Q2FjaGUiLCJpc0JhY2tncm91bmQiLCJ1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUiLCJVUkwiLCJsb2NhdGlvbiIsImhyZWYiLCJyZWYxIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJyZWYiLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsIlJvdXRlciIsInBhdGhuYW1lMSIsInF1ZXJ5MSIsImFzMSIsImluaXRpYWxQcm9wcyIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsInNkYyIsInNiYyIsImlzRmlyc3RQb3BTdGF0ZUV2ZW50IiwiX2tleSIsIm9uUG9wU3RhdGUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJnZXRVUkwiLCJfX05BIiwicmVsb2FkIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwia2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJlMSIsImlzU3NyIiwiX2JwcyIsImNoYW5nZSIsInNoYWxsb3ciLCJfc2hhbGxvdyIsIl9oIiwiY29tcG9uZW50cyIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwic3R5bGVTaGVldHMiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCIsIkJsb29tRmlsdGVyIiwic3RhdGljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSIiwiZHluYW1pY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiIsImhhc2hlcyIsIl9iZmxfcyIsInNpemUiLCJpbXBvcnQiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwicmVwbGFjZSIsIl9iZmwiLCJfdGhpcyIsIm1hdGNoZXNCZmxTdGF0aWMiLCJtYXRjaGVzQmZsRHluYW1pYyIsImN1ckFzIiwiYXNOb1NsYXNoIiwiYXNOb1NsYXNoTG9jYWxlIiwicmVmMiIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJpIiwicmVmMyIsImN1cnJlbnRQYXJ0IiwiaGFzIiwic3BsaXQiLCJqb2luIiwiaXNRdWVyeVVwZGF0aW5nIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsImRldGVjdGVkRG9tYWluIiwiYXNOb0Jhc2VQYXRoIiwic2Nyb2xsIiwicm91dGVQcm9wcyIsImxvY2FsZUNoYW5nZSIsInBhcnNlZCIsInBhcnNlZEFzUGF0aG5hbWUiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInJvdXRlTWF0Y2giLCJyb3V0ZVJlZ2V4Iiwic2hvdWxkSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWRBcyIsIm1pc3NpbmdQYXJhbXMiLCJpc0Vycm9yUm91dGUiLCJyZWY0IiwicmVmNSIsInJlZjYiLCJyb3V0ZUluZm8iLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsImNvbXBvbmVudCIsInNjcmlwdHMiLCJwYXJzZWRIcmVmIiwibm90Rm91bmRSb3V0ZSIsIl8iLCJfcm91dGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3Njcm9sbCIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJyZWY3IiwicmVmOCIsInJlZjkiLCJjYW5Ta2lwVXBkYXRpbmciLCJoYXNoUmVnZXgiLCJlcnIxIiwiaXNMb2NhbFVSTCIsImRldGVjdGVkTG9jYWxlIiwiZG9tYWluIiwiaHR0cCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiX2luRmxpZ2h0Um91dGUiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwib25seUFIYXNoQ2hhbmdlIiwic2Nyb2xsVG9IYXNoIiwic2V0IiwidXJsSXNOZXciLCJwIiwiZXh0ZXJuYWxEZXN0IiwiaW50ZXJwb2xhdGVBcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJwYXJhbSIsIm9wdGlvbmFsIiwiY29uc29sZSIsIndhcm4iLCJvbWl0IiwiZ2V0Um91dGVJbmZvIiwiZm9yRWFjaCIsInVuc3RhYmxlX3NjcmlwdExvYWRlciIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsImlzTm90Rm91bmQiLCJzdGF0dXNDb2RlIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhbmRsZVJvdXRlSW5mb0Vycm9yIiwibG9hZEVycm9yRmFpbCIsImdpcEVyciIsInJvdXRlSW5mb0VyciIsImlzQXNzZXRFcnJvciIsImdldEluaXRpYWxQcm9wcyIsInJlcXVlc3RlZFJvdXRlIiwicmVmMTAiLCJyZWYxMSIsInJlZjEyIiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsInJlc29sdmVkUm91dGUiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsInNob3VsZEZldGNoRGF0YSIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJpc0FQSVJvdXRlIiwicmVzIiwibW9kIiwiX2dldERhdGEiLCJmZXRjaGVkIiwiZ2V0UHJvcGVyRXJyb3IiLCJiZWZvcmVQb3BTdGF0ZSIsImNiIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwicHJlZmV0Y2giLCJvcmlnaW5hbFBhdGhuYW1lIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiX2dldEZsaWdodERhdGEiLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/next@13.2.4_biqbaboplfbrettd7655fr4n2y/node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});